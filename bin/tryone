#!/usr/bin/env fish

# Define option specifications
set -l options (fish_opt --short h --long help)
set options $options (fish_opt --short c --long crop --required-val)
set options $options (fish_opt --short x --long crop-left --required-val)
set options $options (fish_opt --short v --long crop-right --required-val)
set options $options (fish_opt --short t --long trim --required-val)
set options $options (fish_opt --short r --long trim-left --required-val)
set options $options (fish_opt --short y --long trim-right --required-val)

if not argparse --min-args 1 $options -- $argv
  exit 1
end

# Handle the help flag
if set --query _flag_help
  echo usage: (basename (status filename)) [OPTIONS] NUMBER ...
  echo options:
  echo   -h,--help           Show this help message.
  echo   -c,--crop GEOMETRY  Crop both image by GEOMETRY.
  echo                       GEOMETRY format is WIDTHxHEIGHT+LEFT+TOP.
  echo                       Use -x,--crop-left and -v,--crop-right to
  echo                       specify different GEOMETRY for left/right.
  echo   -t,--trim=NUM_PIXELS
  echo                       Trim both outer edges by NUM_PIXELS.
  echo                       Minus number of NUM_PIXELS trims inner edges.
  echo                       Use -r,--trim-left and -u,--trim-right to
  echo                       specify different NUM_PIXELS for left/right.
  return
end

if set --query _flag_crop
  if string match --quiet --regex '^(?<geometry>[[:digit:]]+x[[:digit:]]+\+[[:digit:]]+\+[[:digit:]]+)$' -- "$_flag_crop"
    set cropl -crop {$geometry}
    set cropr -crop {$geometry}
  else
    echo crop: expected WIDTHxHEIGHT+LEFT+TOP\; got \"{$_flag_crop}\" >&2
    exit 1
  end
end

if set --query _flag_crop_left
  if string match --quiet --regex '^(?<geometry>[[:digit:]]+x[[:digit:]]+\+[[:digit:]]+\+[[:digit:]]+)$' -- "$_flag_crop"
    set cropl -crop {$geometry}
  else
    echo crop-left: expected WIDTHxHEIGHT+LEFT+TOP\; got \"{$_flag_crop}\" >&2
    exit 1
  end
end

if set --query _flag_crop_right
  if string match --quiet --regex '^(?<geometry>[[:digit:]]+x[[:digit:]]+\+[[:digit:]]+\+[[:digit:]]+)$' -- "$_flag_crop"
    set cropr -crop {$geometry}
  else
    echo crop-right: expected WIDTHxHEIGHT+LEFT+TOP\; got \"{$_flag_crop}\" >&2
    exit 1
  end
end

if set --query _flag_trim
  if string match --quiet --regex -- '^(?<pixel>[[:digit:]]+)$' {$_flag_trim}
    set cropl -gravity west -chop {$pixel}x0
    set cropr -gravity east -chop {$pixel}x0
  else if string match --quiet --regex -- '^-(?<pixel>[[:digit:]]+)$' {$_flag_trim}
    set cropl -gravity east -chop {$pixel}x0
    set cropr -gravity west -chop {$pixel}x0
  else
    echo trim: expected a positive/negative number\; got \"{$_flag_trim}\" >&2
    exit 1
  end
end

if set --query _flag_trim_left
  if string match --quiet --regex -- '^(?<pixel>[[:digit:]]+)$' {$_flag_trim_left}
    set cropl -gravity west -chop {$pixel}x0
  else if string match --quiet --regex -- '^-(?<pixel>[[:digit:]]+)$' {$_flag_trim_left}
    set cropl -gravity east -chop {$pixel}x0
  else
    echo trim-left: expected a positive/negative number\; got \"{$_flag_trim_left}\" >&2
    exit 1
  end
end

if set --query _flag_trim_right
  if string match --quiet --regex -- '^(?<pixel>[[:digit:]]+)$' {$_flag_trim_right}
    set cropr -gravity east -chop {$pixel}x0
  else if string match --quiet --regex -- '^-(?<pixel>[[:digit:]]+)$' {$_flag_trim_right}
    set cropr -gravity west -chop {$pixel}x0
  else
    echo trim-right: expected a positive/negative number\; got \"{$_flag_trim_right}\" >&2
    exit 1
  end
end

set tmp_dir (mktemp --directory --tmpdir)

for arg in {$argv}
  if string match --quiet --regex -- '^0*(?<num>[[:digit:]]{1,3})$' {$arg}
    set right (string pad --char 0 --width 3 {$num})
    set left (string pad --char 0 --width 3 (math {$num}+1))
    set --erase right_files
    for ext in png webp jpg
      if test -e {$right}.{$ext}
        set right_files {$right_files} {$right}.{$ext}
      end
    end
    if [ (count {$right_files}) -ge 1 ]
      set --erase left_files
      for ext in png webp jpg
        if test -e {$left}.{$ext}
          set left_files {$left_files} {$left}.{$ext}
        end
      end
      if [ (count {$left_files}) -ge 1 ]
        if [ (count {$right_files}) -eq 1 -a (count {$right_files}) -eq 1 ]
          set output _{$right}b.jpg
          magick {$left_files[1]} {$cropl} \( {$right_files[1]} {$cropr} \) +append {$tmp_dir}/{$output}
          mv {$tmp_dir}/{$output} {$output}
          echo {$left_files[1]} + {$right_files[1]} =\> {$output}
        else
          for right_file in {$right_files}
            for left_file in {$left_files}
              set output _{$left_file}+{$right_file}.jpg
              magick \( {$left_file} {$cropl} \( {$right_file} {$cropr} \) +append {$tmp_dir}/{$output}
              mv {$tmp_dir}/{$output} {$output}
              echo {$left_file} + {$right_file} =\> {$output}
            end
          end
        end
      else
        echo (basename (status filename)): \"{$left}.{png,webp,jpg}\" not found >&2
      end
    else
      echo (basename (status filename)): \"{$right}.{png,webp,jpg}\" not found >&2
    end
  else
    echo (basename (status filename)): expected a number from 0 to 999\; got \"{$arg}\" >&2
  end
end

# Clean up
rmdir {$tmp_dir}
