#!/usr/bin/env fish

function display_help
  echo usage: (basename (status filename)) [OPTIONS] FROM_NUM TO_NUM
  echo options:
  echo "  -h,--help           Show this help message."
  echo "  -crop GEOMETRY      Crop both image by GEOMETRY."
  echo "                      GEOMETRY format is WIDTHxHEIGHT+LEFT+TOP."
  echo "                      Use -crop-left and -crop-right to specify"
  echo "                      different GEOMETRY for left/right."
  echo "  -trim=NUM_PIXELS    Trim both outer edges by NUM_PIXELS."
  echo "                      Minus number of NUM_PIXELS trims inner edges."
  echo "                      Use -trim-left and -trim-right to specify"
  echo "                      different NUM_PIXELS for left/right."
end

set --erase propagated_args

while test (count {$argv}) -gt 0
  switch $argv[1]
    case '-crop'
      if test (count {$argv}) -gt 1
        if string match --quiet --regex -- '^(?<geometry>[[:digit:]]+x[[:digit:]]+\+[[:digit:]]+\+[[:digit:]]+)$' {$argv[2]}
          set propagated_args {$propagated_args} -crop {$geometry}
          set argv {$argv[3..]}
        else
          echo crop: expected WIDTHxHEIGHT+LEFT+TOP\; got {$argv[2]}
          exit 1
        end
      else
        echo crop: required WIDTHxHEIGHT+LEFT+TOP
        exit 1
      end
    case '-crop-left'
      if test (count {$argv}) -gt 1
        if string match --quiet --regex -- '^(?<geometry>[[:digit:]]+x[[:digit:]]+\+[[:digit:]]+\+[[:digit:]]+)$' {$argv[2]}
          set propagated_args {$propagated_args} -crop-left {$geometry}
          set argv {$argv[3..]}
        else
          echo crop-left: expected WIDTHxHEIGHT+LEFT+TOP\; got {$argv[2]}
          exit 1
        end
      else
        echo crop-left: required WIDTHxHEIGHT+LEFT+TOP
        exit 1
      end
    case '-crop-right'
      if test (count {$argv}) -gt 1
        if string match --quiet --regex -- '^(?<geometry>[[:digit:]]+x[[:digit:]]+\+[[:digit:]]+\+[[:digit:]]+)$' {$argv[2]}
          set propagated_args {$propagated_args} -crop-right {$geometry}
          set argv {$argv[3..]}
        else
          echo crop-right: expected WIDTHxHEIGHT+LEFT+TOP\; got {$argv[2]}
          exit 1
        end
      else
        echo crop-right: required WIDTHxHEIGHT+LEFT+TOP
        exit 1
      end
    case '-trim'
      if test (count $argv) -gt 1
        if string match --quiet --regex -- '^(?<pixel>-?[[:digit:]]+)$' {$argv[2]}
          set propagated_args {$propagated_args} -trim {$pixel}
          set argv {$argv[3..]}
        else
          echo trim: expected a positive/negative number\; got \"{$argv[2]}\" >&2
          exit 1
        end
      else
        echo trim: expected a positive/negative number
        exit 1
      end
    case '-trim-left'
      if test (count $argv) -gt 1
        if string match --quiet --regex -- '^(?<pixel>-?[[:digit:]]+)$' {$argv[2]}
          set propagated_args {$propagated_args} -trim-left {$pixel}
          set argv {$argv[3..]}
        else
          echo trim-left: expected a positive/negative number\; got \"{$argv[2]}\" >&2
          exit 1
        end
      else
        echo trim-left: expected a positive/negative number
        exit 1
      end
    case '-trim-right'
      if test (count $argv) -gt 1
        if string match --quiet --regex -- '^(?<pixel>[[:digit:]]+)$' {$argv[2]}
          set crop_right -gravity east -chop {$pixel}x0
          set argv {$argv[3..]}
        else if string match --quiet --regex -- '^-(?<pixel>[[:digit:]]+)$' {$argv[2]}
          set crop_right -gravity west -chop {$pixel}x0
          set argv {$argv[3..]}
        else
          echo trim-right: expected a positive/negative number\; got \"{$argv[2]}\" >&2
          exit 1
        end
      else
        echo trim-right: expected a positive/negative number
        exit 1
      end
    case '-two'
      set two true
      if not test -e two
        mkdir two
      end
    case '-h' '--help'
      display_help
      exit 0
    case '*'
      break
  end
end

set begin 1
set end 997

if test (count {$argv}) -ge 1
  if not string match --quiet --regex -- '^0*(?<begin>[[:digit:]]{1,3})$' {$argv[1]}
    echo (basename (status filename)): expected a number from 0 to 999\; got \"{$argv[1]}\" >&2
    exit 1
  else
    if test (math {$begin} % 2) -eq 0
      set begin (math {$begin}+1)
    end
  end
end

if test (count {$argv}) -eq 2
  if not string match --quiet --regex -- '^0*(?<end>[[:digit:]]{1,3})$' {$argv[2]}
    echo (basename (status filename)): expected a number from 0 to 999\; got \"{$argv[2]}\" >&2
    exit 1
  else
    if test (math {$end} % 2) -eq 0
      set end (math {$end}-1)
    end
  end
end

fd --exact-depth 1 --print0 --strip-cwd-prefix=always ^\((seq -f %03g -s \| {$begin} 2 {$end})\)\\.\(jpg\|webp\|png\)\$ \
  | sed --null-data --regexp-extended s/\\.\(jpg\|webp\|png\)\$//\;s/^0\+\(.\)/\\1/ \
  | xargs --null fish --command '
      set --erase result
      for arg in {$argv}
        for ext in jpg png webp
          if test -e (string pad --char 0 --width 3 (math 1+{$arg})).{$ext}
            set result {$result} {$arg}
          end
        end
      end
      string join0 {$result}' \
  | parallel --null tryone {$propagated_args}
